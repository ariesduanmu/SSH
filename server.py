import base64from binascii import hexlifyimport osimport socketimport sysimport getoptimport threadingimport tracebackimport paramikoimport argparsefrom paramiko.py3compat import b, u, decodebytesparamiko.util.log_to_file('server.log')def host_private_key(private_key_path):    return paramiko.RSAKey(filename=private_key_path)def host_public_key(public_key_path):    with open(public_key_path, "rb") as f:        public_key_data = f.read().split(b" ")[1]    return paramiko.RSAKey(data = decodebytes(public_key_data))class Server(paramiko.ServerInterface):    def __init__(self):        self.event = threading.Event()    def check_channel_request(self, kind, channelid):        if kind == "session":            return paramiko.OPEN_SUCCEEDED        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED    def check_auth_password(self, username, password):        if(username == "aries" and password == "secret"):            return paramiko.AUTH_SUCCESSFUL        return paramike.AUTH_FAILED        def check_auth_publickey(self, username, key):        public_key = host_public_key("keys/host_rsa_key.pub")        if(username == "aries") and (key == public_key):            return paramiko.AUTH_SUCCESSFUL        return paramiko.AUTH_FAILED    def check_auth_gssapi_with_mic(        self, username, gss_authenticated=paramiko.AUTH_FAILED, cc_file=None    ):        if gss_authenticated == paramiko.AUTH_SUCCESSFUL:            return paramiko.AUTH_SUCCESSFUL        return paramiko.AUTH_FAILED    def check_auth_gssapi_keyex(        self, username, gss_authenticated=paramiko.AUTH_FAILED, cc_file=None    ):        if gss_authenticated == paramiko.AUTH_SUCCESSFUL:            return paramiko.AUTH_SUCCESSFUL        return paramiko.AUTH_FAILED    def enable_auth_gssapi(self):        return True    def get_allowed_auths(self, username):        return "gssapi-keyex,gssapi-with-mic,password,publickey"    def check_channel_shell_request(self, channel):        self.event.set()        return True    def check_channel_pty_request(        self, channel, term, width, height, pixelwidth, pixelheight, modes    ):        return Truedef ssh_server(port):    DoGSSAPIKeyExchange = True    try:        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        sock.bind(("localhost", port))    except Exception as e:        print(f"[-] Bind failed: {e}")        traceback.print_exc()        sys.exit(1)    try:        sock.listen(100)        print("[+] Listening for connection...")        client, addr = sock.accept()    except Exception as e:        print(f"[-] Listen failed: {e}")        traceback.print_exc()        sys.exit(1)    print("[+] Got a connection")    try:        bhSession = paramiko.Transport(client, gss_kex=DoGSSAPIKeyExchange)        bhSession.add_server_key(host_private_key("keys/host_rsa_key"))        server = Server()        try:            bhSession.start_server(server=server)        except paramiko.SSHException as x:            print("[-] SSH negotiation failed")        chan = bhSession.accept(20)        if chan is None:            print("[-] No channel.")            sys.exit(1)        print("[+] Authenticated")        chan.send('Welcome to the SSH')        while True:            try:                command = input("Enter command: ").strip('\n')                if command != 'exit':                    chan.send(command)                    print(chan.recv(1024))                else:                    chan.send('exit')                    print('exiting')                    bhSession.close()            except KeyboardInterrupt:                chan.close()                bhSession.close()    except Exception as e:        print("[-] Caught exception: " + str(e))        traceback.print_exc()        try:            bhSession.close()        except:            pass        sys.exit(1)def parse_options():    parser = argparse.ArgumentParser(usage='%(prog)s <-u username> <-m password> [-p port]',                                     description='SSH is Paramiko based SSH tool @Ludisposed & @Qin',                                     formatter_class=argparse.RawDescriptionHelpFormatter,                                     epilog='''Examples:python server.py -u username -m passwordpython server.py -p port -u username -m password'''                                     )    # parser.add_argument('-u','--username', type=str, help='username use to auth')    # parser.add_argument('-m','--magic', dest='password', type=str, help='password use to auth')    parser.add_argument('-p','--port',type=int, default=22, help='port use for ssh server, default is 22')    args = parser.parse_args()    # if args.username == None:    #     parser.error('Username can not be none')    # if args.password == None:    #     parser.error('Password can not be none')    return argsif __name__ == "__main__":    args = parse_options()    ssh_server(args.port)