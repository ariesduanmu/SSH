import base64from binascii import hexlifyimport osimport socketimport sysimport getoptimport threadingimport tracebackimport paramikoimport argparsefrom paramiko.py3compat import b, u, decodebytesparamiko.util.log_to_file('server.log')host_key = paramiko.RSAKey(filename='test_rsa.key')public_key_data = (b'AAAAB3NzaC1yc2EAAAABIwAAAIEAyO4it3fHlmGZWJaGrfeHOVY7RWO3P9M7hp'                   b'fAu7jJ2d7eothvfeuoRFtJwhUmZDluRdFyhFY/hFAh76PJKGAusIqIQKlkJxMC'                   b'KDqIexkgHAfID/6mqvmnSJf0b5W8v5h2pI/stOSwTQ+pxVhwJ9ctYDhRSlF0iT'                   b'UWT10hcuO4Ks8=')public_key = paramiko.RSAKey(data = decodebytes(public_key_data))class Server (paramiko.ServerInterface):    def __init__(self):        self.event = threading.Event()    def check_channel_request(self, kind, channelid):    	if kind == "session":    		return paramiko.OPEN_SUCCEEDED        return paramiko.OPEN_FAILED_ADMINISTRATIVELY_PROHIBITED    def check_auth_password(self, u, p):        if(u == username and p == password):            return paramiko.AUTH_SUCCESSFUL        return paramike.AUTH_FAILED        def check_auth_publickey(self, username, key):        if(username == username) and (key == public_key):            return paramiko.AUTH_SUCCESSFUL        return paramiko.AUTH_FAILED        def get_allowed_auths(self, username):        return 'password, publickey'def ssh_server(username, password, port):    try:        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)        sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)        sock.bind(("localhost", port))        sock.listen(5)        print "[+] Listening for connection..."        client, addr = sock.accept()    except Exception,e:        print "[-] Listen failed: " + str(e)        sys.exit(1)    print "[+] Got a connection"    try:        bhSession = paramiko.Transport(client)        bhSession.add_server_key(host_key)        server = Server()        try:            bhSession.start_server(server = server)        except paramiko.SSHException, x:            print "[-] SSH negotiation failed"        chan = bhSession.accept(20)        print "[+] Authenticated"        print chan.recv(1024)        chan.send('Welcome to the SSH')        while True:            try:                command = raw_input("Enter command: ").strip('\n')                if command != 'exit':                    chan.send(command)                    print(chan.recv(1024))                else:                    chan.send('exit')                    print('exiting')                    bhSession.close()                    raise Exception ('exit')            except KeyboardInterrupt:                bhSession.close()    except Exception, e:        print "[-] Caught exception: " + str(e)        try:            bhSession.close()        except:            pass        sys.exit(1)def parse_options():    parser = argparse.ArgumentParser(usage='%(prog)s <-u username> <-m password> [-p port]',                                     description='SSH is Paramiko based SSH tool @Ludisposed & @Qin',                                     formatter_class=argparse.RawDescriptionHelpFormatter,                                     epilog='''Examples:python2.7 server.py -u username -m passwordpython2.7 server.py -p port -u username -m password'''                                     )    parser.add_argument('-u','--username', type=str, help='username use to auth')    parser.add_argument('-m','--magic', dest='password', type=str, help='password use to auth')    parser.add_argument('-p','--port',type=int, default=22, help='port use for ssh server, default is 22')    args = parser.parse_args()    if args.username == None:        parser.error('Username can not be none')    if args.password == None:        parser.error('Password can not be none')    return argsif __name__ == "__main__":    args = parse_options()    global username    global password    username = args.username    password = args.password    ssh_server(username, password, args.port)